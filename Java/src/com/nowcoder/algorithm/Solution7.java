package com.nowcoder.algorithm;

/// 寻找第K大的数

public class Solution7 {

	/*
	 * 有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。
	 * 给定一个整数数组a,同时给定它的大小n和要找的K(K在1到n之间)，
	 * 请返回第K大的数，保证答案存在。
	 * 
	 * 首先回顾一下快排的思路：
	 * 选基准数，大数换到后面，小数换到前面
	 * */
	public int findKth(int[] a, int n, int K) {
        QuickSort1(a, 0, n-1, K);
        return a[K-1];
//        return findK(a, 0, n-1, K);
    }
	
	/**
	 * @return 返回调整后基准数的位置
	 * */
	public static int AdjustArray(int []a, int start, int end) {
		int benchmark=a[start]; // a[i]就是第一个坑
		
		int i=start, j=end;
		while (i<j) {
			// 从右向左找小于基准的数来填a[i]
			while (i < j && benchmark > a[j]) j--;
			if(i < j) {
	            a[i] = a[j]; //将a[j]填到a[i]中，a[j]就形成了一个新的坑
	            i++;
	        }
			// 从左向右找大于或等于基准的数来填a[j]
			while (i < j && benchmark < a[i]) i++;
			if(i < j) {
	            a[j] = a[i]; //将a[i]填到a[j]中，ai]就形成了一个新的坑
	            j--;
	        }
		}
		//退出时，i等于j。将基准填到这个坑中。
	    a[i] = benchmark;
	    return i;
	}
	
	public static void QuickSort(int []a, int start, int end) {
		if (start < end){
	        int i = AdjustArray(a, start, end); //先成挖坑填数法调整a[]
	        // 为什么-1,+1，应为i的位置存着基准
	        QuickSort(a, start, i - 1); // 递归调用
	        QuickSort(a, i + 1, end);
	    }
	}
	
	public static void QuickSort1(int []a, int start, int end, int K) {
		if (start < end){
	        int i = AdjustArray(a, start, end); //先成挖坑填数法调整a[]
	        // 为什么-1,+1，应为i的位置存着基准
	        if(K==i-1) {
	        	return;
	        }
	        if (i<K-1) {
//	        	QuickSort1(a, start, i - 1, K); // 递归调用
	        	QuickSort1(a, i + 1, end, K);
			}
	        else {
//	        	QuickSort1(a, i + 1, end, K);
	        	QuickSort1(a, start, i - 1, K); // 递归调用
			} // 单边有bug
//	        QuickSort1(a, start, i - 1, K); // 递归调用
//	        QuickSort1(a, i + 1, end, K);
	    }
	}
	
	public static int partition(int[] arr, int left, int right) {
        int pivot = arr[left];
 
        while (left < right) {
            while (left < right && arr[right] <= pivot) {
                right--;
            }
            arr[left] = arr[right];
            while (left < right && arr[left] >= pivot) {
                left++;
            }
            arr[right] = arr[left];
        }
        arr[left] = pivot;
        return left;
    }
 
    public static int findK(int[] arr, int left, int right, int k) {
        if (left <= right) {
            int pivot = partition(arr, left, right);
 
            if (pivot == k - 1) { // 因为这个？
                return arr[pivot];
            } else if (pivot < k - 1) {
                return findK(arr, pivot + 1, right, k);
            } else {
                return findK(arr, left, pivot - 1, k);
            }
        }
        return -1;
    }
	
	public static void main(String[] args) {
		int [] arr = {1,3,5,2,2};
		int [] arr1 = {1332802,1177178,1514891,871248,753214,123866,1615405,328656,1540395,968891,1884022,
				252932,1034406,1455178,821713,486232,860175,1896237,852300,566715,1285209,1845742,883142,
				259266,520911,1844960,218188,1528217,332380,261485,1111670,16920,1249664,1199799,1959818,
				1546744,1904944,51047,1176397,190970,48715,349690,673887,1648782,1010556,1165786,937247,
				986578,798663};
		int [] arr2 = {1710031,1306379,715499,1311927,1394696,1808211,502799,768069,1000577,1287429,1237130,
				306887,1655756,140786,1297002,274583,743562,1721870,290230,255825,96201,301686,169803,937655,
				1172993,460369,403557,1587591,1801382,1652676,532413,1679360,573965,1590827,641915,1340474,
				1679251,1917939,965743,98830,626081,565791,113528,1470420,1357194,1992208,523242,1790571,
				861076,579431,1648878,1678981,616277,1401094,741405,60378,515123,256859,1303600,1081994,
				31122,1787762,510928,437842,600713,824213,1962835,1572101,586494,1198440,305384,886637,
				1910521,1375468,580436,1386588,818041,1371271,210348,1214034,1651801,1219706,1139636,1022787,
				182308,1005092,1790746,521562,1918421,1978282,918998,685165,982877,728641,974135,1642207,
				328571,277759,1171510,951348,234662,1753919,403901,1422834,1889048,1135315,966577,378051,
				939848,1971354,1131442,1657484,18133,401574,479814,1556326,1092668,222734,80623,1892266,
				865086,710445,1307541,223475,1050735,85102,1025365,687310,913345,672101,627345,426537,1577995,
				1454877,158246,1781452,1890266,1049758,1452576,1386339,783183,1784566,140886,1813677,122293,
				1295800,996721,375554,297441,836599,992428,1413931,318124,369563,1495519,285892,1910894,297368,
				1440853,507535,1854307,212726,1453681,152940,309,887315,1780236,489101,1882033,1482823,1113522,
				1893756,885802,1865031,1719122,1549728,188223,23271,244267,592265,1034001,1114519,516582,499273,
				109483,1033755,1483068,1005081,1283081,1326338,1915172,513300,959230,1194448,924087,1834846,
				78977,877520,594610,1693165,1892463,1495029,1218742,1558747,152593,1474701,326115,412469,
				1289728,1034276,232953,653118,586207,1230287,832233,1882844,1318643,210211,892323,1628841,
				395137,1611802,1842104,1992913,746261,1064485,1451505,140012,1705271,59669,361608,1489522,
				762832,658386,255192,1895296,102730,332493,1521771,867276,1098358,363126,687719,1217918,
				1231342,238626,466235,1259132,1684331,815053,1345066,1692882,1241286,1808952,1673755,289679,
				1489981,1109541,652872,594128,162177,1781164,1405096,1350121,106205,1881870,1645259,451093,
				1499002,1727325,1247041,565554,1464972,591644,1377216,359683,1616820,206999,328944,628640,
				438172,1441620,1083493,946312,885788,1609636,32674,68621,518905,1522785};

		Solution7 s7= new Solution7();
		System.out.println(s7.findKth(arr, 5, 3));
		System.out.println(s7.findKth(arr1, 49, 24));
		System.out.println(s7.findKth(arr2, 290, 249));
		
		QuickSort(arr, 0, 4);
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i]);
		}
		System.out.println();
		QuickSort1(arr2, 0, arr2.length-1, 24);
		for (int i = 0; i < arr2.length; i++) {
			System.out.print(arr2[i]+"\t");
			if ((i+1)%9==0) {
				System.out.println();
			}
		}
	}

}
